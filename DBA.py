import numpy as np


m = 16  # 대안 개수
n = 12  # 성능 지표 개수

Aij_values = [
    [-14.529, 405.557, 20.474, 24.502, 0.979, 1.539, 838.804, 33.115,36.162, 0.497, 8171.137, 26.923],
    [1.887, 29.799, 4.280, 5.148, 0.155, 1.054, 0.640, 6.687, 6.948, 0.961, 635.976, 7.511],
    [5.118, 80.500, 6.710, 10.228, 0.237, 1.181, 0.137, 13.062, 14.029, 0.897, 1699.999, 12.172],
    [1.835, 28.004, 4.486, 5.061, 0.153, 1.061, 0.635, 6.578, 6.829, 0.962, 620.073, 7.417],
    [0.780, 0.673, 1.674, 1.590, 0.047, 2.063, 0.028, 2.406, 2.529, 0.995, 73.456, 2.553],
    [2.082, 32.356, 4.737, 5.498, 0.565, 0.222, 0.621, 7.135, 7.433, 0.957, 707.129, 7.920],
    [2.554, 42.546, 4.941, 6.325, 0.188, 0.889, 0.558, 8.215, 8.603, 0.945, 890.917, 8.890],
    [10.210, 390.340, 13.629, 20.978, 0.558, 0.997, 0.774, 27.262, 29.111, 0.516, 7866.797, 26.417],
    [4.097, 182.655, 13.655, 21.715, 0.857, 5.479, 5.852, 15.762, 16.286, 0.772, 3713.102, 18.149],
    [-7.173, 105.795, 9.700, 12.358, 0.156, 3.928, 10.593, 16.612, 18.095, 0.867, 2155.899, 13.829],
    [7.833, 205.490, 10.036, 15.669, 0.393, 3.542, 0.270, 20.328, 21.785, 0.744, 4169.792, 19.233],
    [40.506, 1919.854, 47.654, 8.246, 0.859, 0.446, 2.679, 84.884, 94.054, -1.365, 38457.074, 58.409],
    [4.231, 83.666, 7.366, 9.272, 0.265, 1.160, 0.533, 12.199, 12.912, 0.892, 1753.321, 12.472],
    [1.870, 26.539, 5.120, 5.119, 0.682, 1.056, 0.638, 6.651, 6.909, 0.961, 630.784, 7.480],
    [-7.437, 112.372, 10.624, 12.881, 0.163, 3.979, 10.276, 17.207, 18.745, 0.858, 2307.430, 14.307],
    [1.873, 26.562, 5.121, 5.122, 0.706, 0.290, 0.638, 6.656, 6.915, 0.961, 631.242, 7.483]
]

np.set_printoptions(formatter={'all': lambda x: f'{x:.5f}'})
# Aij 값을 numpy 배열로 변환
Aij_values = np.abs(np.array(Aij_values))
Aij = np.array(Aij_values)
print(f"기본 배열 {Aij}")


# 각 열의 절댓값 중에서 가장 작은 값을 찾아서 min_abs_values 리스트에 저장
min_abs_values = np.min(np.abs(Aij), axis=0)

# 10번째 열의 절댓값을 가장 큰 값으로 설정
max_abs_value = np.max(Aij[:, 9])
min_abs_values[9] = max_abs_value

# min_abs_values를 행렬 Aij에 추가
Aij = np.vstack([Aij, min_abs_values])

# 출력 시 소수점 다섯 번째 자리까지 표시

print(f"변경된 배열:\n{Aij}")

#데이터 정규화과정(1)
# 각 열의 최대값과 최소값 계산
# Case-I: 속성 값이 작을수록 실제 데이터에 잘 맞을 때



for j in range(n):
    if j in [9]:
        Aij[:, j] = Aij[:, j] - np.min(Aij[:, j])

    else:
        Aij[:, j] = np.max(Aij[:, j]) - Aij[:, j]


# 마지막 행 제외
Aij_without_last_row = Aij[:-1]

# 각 열의 평균 계산 (마지막 행 제외)
column_means = np.mean(Aij_without_last_row, axis=0)
print(f"평균: {column_means}")

# 각 열의 표준편차 계산 (마지막 행 제외)
column_std_devs = np.std(Aij_without_last_row, axis=0)
print(f"표준편차: {column_std_devs}")

# Zij 값 계산 (마지막 행 제외)
# 전체 행을 사용하여 Zij 값 계산
Zij = (Aij - column_means) / column_std_devs


print(Zij)


# 마지막 행 삭제
for j in range(n):
    Zij[:, j] =  Zij[-1, j]-Zij[:, j]

# 마지막 행 삭제
Zij_without_last_row = Zij[:-1]


print("최종행렬(z행렬):")
print(Zij_without_last_row)



row_sums = np.sum(Zij_without_last_row**2, axis=1)
print(row_sums)
CD_OP_Alt_matrix = np.sqrt(row_sums)

print("CD_{OP-Alt} 값:")
print(CD_OP_Alt_matrix )

# CD_{OP-Alt} 값을 작은 순서대로 정렬한 인덱스
ranked_indices = np.argsort(CD_OP_Alt_matrix)

# 작은 순서대로 랭킹을 매기기 위한 배열 생성
ranks = np.arange(len(CD_OP_Alt_matrix)) + 1

# 작은 순서대로 랭킹을 출력
print("작은 순서대로 랭킹:")
for index, rank in zip(ranked_indices, ranks):
    print(f"Index {rank}등: {index+1} ")